#!/usr/bin/env npx tsx
/**
 * Prisma Auxiliary Types Generator
 *
 * Genera tipos TypeScript auxiliares para queries complejas:
 * - Types con relaciones incluidas (WithRelations)
 * - Types para select parciales
 * - Types para input de creación/actualización
 * - Tipos de filtros comunes
 *
 * Uso:
 *   npx tsx scripts/prisma-types-generator.ts
 *   npx tsx scripts/prisma-types-generator.ts --only WorkOrder,Company
 *   npx tsx scripts/prisma-types-generator.ts --output lib/prisma-types.ts
 */

import * as fs from 'fs';
import * as path from 'path';

const SCHEMA_PATH = path.join(__dirname, '..', 'prisma', 'schema.prisma');
const DEFAULT_OUTPUT = path.join(__dirname, '..', 'lib', 'prisma-types.generated.ts');

// ─── Parser ─────────────────────────────────────────────────────────────────

interface PrismaField {
  name: string;
  baseType: string;
  isOptional: boolean;
  isList: boolean;
  isId: boolean;
  isUnique: boolean;
  defaultValue: string | null;
  isRelation: boolean;
  isAutoGenerated: boolean;
}

interface PrismaModel {
  name: string;
  fields: PrismaField[];
}

interface PrismaEnum {
  name: string;
  values: string[];
}

const PRIMITIVE_MAP: Record<string, string> = {
  String: 'string',
  Int: 'number',
  Float: 'number',
  Boolean: 'boolean',
  DateTime: 'Date',
  Json: 'JsonValue',
  BigInt: 'bigint',
  Decimal: 'Decimal',
  Bytes: 'Buffer',
};

function parseSchema(content: string): { models: PrismaModel[]; enums: PrismaEnum[] } {
  const lines = content.split('\n');
  const models: PrismaModel[] = [];
  const enums: PrismaEnum[] = [];

  // First pass: collect enum names
  const enumNames = new Set<string>();
  for (const l of lines) {
    const trimmed = l.trim();
    if (trimmed.startsWith('enum ')) {
      enumNames.add(trimmed.replace('enum ', '').replace('{', '').trim());
    }
  }

  let i = 0;
  while (i < lines.length) {
    const line = lines[i].trim();

    if (line.startsWith('model ')) {
      const modelName = line.replace('model ', '').replace('{', '').trim();
      const blockLines: string[] = [];
      let braceCount = 1;
      i++;
      while (i < lines.length && braceCount > 0) {
        if (lines[i].includes('{')) braceCount++;
        if (lines[i].includes('}')) braceCount--;
        if (braceCount > 0) blockLines.push(lines[i]);
        i++;
      }
      models.push(parseModelBlock(modelName, blockLines, enumNames));
      continue;
    }

    if (line.startsWith('enum ')) {
      const enumName = line.replace('enum ', '').replace('{', '').trim();
      const blockLines: string[] = [];
      let braceCount = 1;
      i++;
      while (i < lines.length && braceCount > 0) {
        if (lines[i].includes('{')) braceCount++;
        if (lines[i].includes('}')) braceCount--;
        if (braceCount > 0) blockLines.push(lines[i]);
        i++;
      }
      enums.push({
        name: enumName,
        values: blockLines.map(l => l.trim()).filter(l => l && !l.startsWith('//')),
      });
      continue;
    }
    i++;
  }

  return { models, enums };
}

function parseModelBlock(name: string, blockLines: string[], enumNames: Set<string>): PrismaModel {
  const fields: PrismaField[] = [];

  for (const line of blockLines) {
    const trimmed = line.replace(/\/\/.*$/, '').trim();
    if (!trimmed || trimmed.startsWith('@@')) continue;

    const match = trimmed.match(/^(\w+)\s+(\w+)(\[\])?\??/);
    if (!match) continue;

    const [, fieldName, baseType, isList] = match;
    const isOptional = trimmed.includes('?');
    const isId = trimmed.includes('@id');
    const isUnique = trimmed.includes('@unique');

    let defaultValue: string | null = null;
    const defaultIdx = trimmed.indexOf('@default(');
    if (defaultIdx !== -1) {
      let depth = 0;
      let start = defaultIdx + '@default('.length;
      let end = start;
      for (let j = start; j < trimmed.length; j++) {
        if (trimmed[j] === '(') depth++;
        if (trimmed[j] === ')') {
          if (depth === 0) { end = j; break; }
          depth--;
        }
      }
      defaultValue = trimmed.substring(start, end);
    }

    const primitiveTypes = Object.keys(PRIMITIVE_MAP);
    const isRelation = !primitiveTypes.includes(baseType) && !enumNames.has(baseType);

    const isAutoGenerated = isId && (defaultValue === 'autoincrement()' || defaultValue === 'uuid()' || defaultValue === 'cuid()');
    const isTimestamp = fieldName === 'createdAt' || fieldName === 'updatedAt';

    fields.push({
      name: fieldName,
      baseType,
      isOptional,
      isList: !!isList,
      isId,
      isUnique,
      defaultValue,
      isRelation,
      isAutoGenerated: isAutoGenerated || isTimestamp,
    });
  }

  return { name, fields };
}

// ─── Type Generation ────────────────────────────────────────────────────────

function getTsType(field: PrismaField, enums: PrismaEnum[]): string {
  if (PRIMITIVE_MAP[field.baseType]) {
    return PRIMITIVE_MAP[field.baseType];
  }
  // Check if it's an enum
  const enumDef = enums.find(e => e.name === field.baseType);
  if (enumDef) return field.baseType;

  // Otherwise it's a relation type
  return field.baseType;
}

function generateTypes(models: PrismaModel[], enums: PrismaEnum[]): string {
  let output = `// ═══════════════════════════════════════════════════════════════════════════
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated by: npx tsx scripts/prisma-types-generator.ts
// Generated at: ${new Date().toISOString()}
// ═══════════════════════════════════════════════════════════════════════════

import type { Prisma, Decimal } from '@prisma/client';

// JSON value type for Json fields
type JsonValue = Prisma.JsonValue;

`;

  // ── Utility types ─────────────────────────────────────────────────────

  output += `// ─── Utility Types ──────────────────────────────────────────────────────

/**
 * Makes specified keys optional while keeping others required.
 */
type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

/**
 * Type for paginated API responses.
 */
export type PaginatedResponse<T> = {
  data: T[];
  total: number;
  page: number;
  pageSize: number;
  totalPages: number;
};

/**
 * Type for API error responses.
 */
export type ApiError = {
  error: string;
  details?: string;
  code?: string;
};

/**
 * Common query filters for list endpoints.
 */
export type BaseListParams = {
  page?: number;
  pageSize?: number;
  search?: string;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  companyId: number;
};

`;

  const modelMap = new Map(models.map(m => [m.name, m]));

  // ── Generate for each model ───────────────────────────────────────────

  for (const model of models) {
    const scalarFields = model.fields.filter(f => !f.isRelation);
    const relationFields = model.fields.filter(f => f.isRelation);

    output += `// ─── ${model.name} ─────────────────────────────────────────────────\n\n`;

    // Base type (scalar fields only)
    output += `/** Scalar fields of ${model.name} (no relations). */\n`;
    output += `export type ${model.name}Scalar = {\n`;
    for (const field of scalarFields) {
      const tsType = getTsType(field, enums);
      const optMark = field.isOptional ? ' | null' : '';
      output += `  ${field.name}: ${tsType}${optMark};\n`;
    }
    output += `};\n\n`;

    // Create input (without auto-generated fields)
    const createFields = scalarFields.filter(f => !f.isAutoGenerated);
    if (createFields.length > 0) {
      output += `/** Input type for creating a ${model.name}. */\n`;
      output += `export type ${model.name}CreateInput = {\n`;
      for (const field of createFields) {
        const tsType = getTsType(field, enums);
        const optional = field.isOptional || field.defaultValue ? '?' : '';
        const optMark = field.isOptional ? ' | null' : '';
        output += `  ${field.name}${optional}: ${tsType}${optMark};\n`;
      }
      output += `};\n\n`;
    }

    // Update input (all scalar fields optional except id)
    output += `/** Input type for updating a ${model.name}. */\n`;
    output += `export type ${model.name}UpdateInput = Partial<Omit<${model.name}Scalar, 'id'>>;\n\n`;

    // WithRelations type
    if (relationFields.length > 0) {
      output += `/** ${model.name} with all relations loaded. */\n`;
      output += `export type ${model.name}WithRelations = ${model.name}Scalar & {\n`;
      for (const field of relationFields) {
        const targetModel = modelMap.get(field.baseType);
        if (!targetModel) continue; // It's an enum referenced as relation (shouldn't happen)
        const typeName = `${field.baseType}Scalar`;
        if (field.isList) {
          output += `  ${field.name}: ${typeName}[];\n`;
        } else if (field.isOptional) {
          output += `  ${field.name}: ${typeName} | null;\n`;
        } else {
          output += `  ${field.name}: ${typeName};\n`;
        }
      }
      output += `};\n\n`;

      // Partial relations (all optional)
      output += `/** ${model.name} with optional relations. */\n`;
      output += `export type ${model.name}WithOptionalRelations = ${model.name}Scalar & {\n`;
      for (const field of relationFields) {
        const targetModel = modelMap.get(field.baseType);
        if (!targetModel) continue;
        const typeName = `${field.baseType}Scalar`;
        if (field.isList) {
          output += `  ${field.name}?: ${typeName}[];\n`;
        } else {
          output += `  ${field.name}?: ${typeName} | null;\n`;
        }
      }
      output += `};\n\n`;
    }

    // Select type helper
    output += `/** Keys available for selecting ${model.name} fields. */\n`;
    output += `export type ${model.name}SelectKey = keyof ${model.name}Scalar`;
    if (relationFields.length > 0) {
      output += ` | ${relationFields.map(f => `'${f.name}'`).join(' | ')}`;
    }
    output += `;\n\n`;
  }

  // ── Common composed types ─────────────────────────────────────────────

  output += `// ─── Common Composed Query Types ─────────────────────────────────────────\n\n`;

  // Generate common includes for frequently used models
  const commonModels = ['WorkOrder', 'Company', 'User', 'Task', 'Machine', 'Product', 'Sale', 'Client'];
  for (const modelName of commonModels) {
    const model = modelMap.get(modelName);
    if (!model) continue;

    const listRelations = model.fields.filter(f => f.isRelation && !f.isList);
    if (listRelations.length > 0) {
      output += `/** ${modelName} with its parent relations loaded (commonly used in list views). */\n`;
      output += `export type ${modelName}ListItem = ${modelName}Scalar & {\n`;
      for (const field of listRelations) {
        const targetModel = modelMap.get(field.baseType);
        if (!targetModel) continue;
        // Only include scalar fields of parent
        const idAndNameFields = targetModel.fields
          .filter(f => !f.isRelation && (f.isId || f.name === 'name' || f.name === 'email' || f.name === 'title'))
          .map(f => `${f.name}: ${getTsType(f, enums)}${f.isOptional ? ' | null' : ''}`)
          .join('; ');
        if (idAndNameFields) {
          output += `  ${field.name}: { ${idAndNameFields} }${field.isOptional ? ' | null' : ''};\n`;
        }
      }
      output += `};\n\n`;
    }
  }

  // ── Company-scoped filter types ───────────────────────────────────────

  output += `// ─── Company-Scoped Query Helpers ────────────────────────────────────────\n\n`;
  output += `/** Base where clause with companyId (for multi-tenant queries). */\n`;
  output += `export type CompanyScopedWhere<T> = T & { companyId: number };\n\n`;
  output += `/** Base query args with common pagination and sorting. */\n`;
  output += `export type ListQueryArgs = {\n`;
  output += `  skip?: number;\n`;
  output += `  take?: number;\n`;
  output += `  orderBy?: Record<string, 'asc' | 'desc'>;\n`;
  output += `};\n\n`;

  return output;
}

// ─── Main ───────────────────────────────────────────────────────────────────

function main() {
  const args = process.argv.slice(2);

  if (!fs.existsSync(SCHEMA_PATH)) {
    console.error(`Schema not found at ${SCHEMA_PATH}`);
    process.exit(1);
  }

  const outputIdx = args.indexOf('--output');
  const outputPath = outputIdx !== -1 && args[outputIdx + 1]
    ? path.resolve(args[outputIdx + 1])
    : DEFAULT_OUTPUT;

  const onlyIdx = args.indexOf('--only');
  const onlyModels = onlyIdx !== -1 && args[onlyIdx + 1]
    ? args[onlyIdx + 1].split(',').map(n => n.trim())
    : null;

  const schemaContent = fs.readFileSync(SCHEMA_PATH, 'utf-8');
  let { models, enums } = parseSchema(schemaContent);

  if (onlyModels) {
    const onlySet = new Set(onlyModels.map(n => n.toLowerCase()));
    models = models.filter(m => onlySet.has(m.name.toLowerCase()));
  }

  const output = generateTypes(models, enums);

  // Ensure directory exists
  const dir = path.dirname(outputPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(outputPath, output);
  console.log(`✅ Generated ${models.length} model types at ${outputPath}`);
}

main();
